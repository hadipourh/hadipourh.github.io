---
import Layout from '../layouts/Layout.astro'
import { profile } from '@/settings'
import { publications } from '@/data/cv'
import Hero from '@/components/ui/Hero.astro'
import Grid from '@/components/ui/Grid.astro'
import ArticleList from '@/components/ui/ArticleList.astro'
import SecurityInfo from '@/components/ui/SecurityInfo.astro'

const { fullName, title, institute, research_areas } = profile

// Use the uploaded professional profile picture
const profilePicture = '/images/profilepic1.png'
---

<Layout>
	<div data-page="home">
	<!-- Hero Section -->
	<section class='flex items-center gap-12 border-b pb-12'>
		<Hero
			fullName={fullName}
			title={title}
			institute={institute}
			profilePicture={profilePicture}
		/>
	</section>

	<!-- Interactive Terminal Section -->
	<section class='py-12 border-b'>
		<div class='w-full max-w-6xl mx-auto'>
			<h2 class='text-3xl font-bold mb-8'>Quick Message Terminal</h2>
			<p class='text-lg text-gray-600 mb-6'>
				Send me a direct message through this terminal interface! Messages are delivered directly to my Telegram.
			</p>
			
			<div class='w-full'>
				<div class='bg-black border-2 border-green-400 rounded-lg p-6 font-mono text-sm shadow-2xl shadow-green-400/20'>
					<!-- Terminal Header -->
					<div class='flex items-center justify-between mb-4 border-b border-green-400 pb-2'>
						<div class='flex items-center space-x-2'>
							<div class='w-3 h-3 bg-red-500 rounded-full'></div>
							<div class='w-3 h-3 bg-yellow-500 rounded-full'></div>
							<div class='w-3 h-3 bg-green-500 rounded-full'></div>
						</div>
						<span class='text-green-400 text-xs'>secure@crypt0grapher:~$</span>
					</div>

					<!-- Terminal Output - Full Width -->
					<div id='home-terminal-output' class='bg-black text-green-400 p-4 rounded border border-green-400 h-72 overflow-y-auto mb-4 font-mono'>
						<!-- Messages will appear here with typing effect -->
					</div>

					<!-- Terminal Input -->
					<div class='flex items-center space-x-2'>
						<span class='text-green-400'>root@secure:~#</span>
						<input
							id='home-terminal-input'
							type='text'
							placeholder='Enter your message here...'
							class='flex-1 bg-transparent border-none outline-none text-green-400 font-mono placeholder-green-600'
							onkeypress='handleHomeTerminalInput(event)'
						/>
						<button 
							onclick='sendHomeTerminalMessage()'
							class='px-4 py-2 bg-green-900 hover:bg-green-700 text-green-400 border border-green-400 rounded transition-colors font-mono text-xs'>
							[SEND]
						</button>
						<button 
							onclick='clearHomeTerminal()'
							class='px-4 py-2 bg-red-900 hover:bg-red-700 text-red-400 border border-red-400 rounded transition-colors font-mono text-xs'>
							[CLEAR]
						</button>
					</div>

					<!-- Security Notice -->
					<div class='mt-4 text-xs text-amber-500 border-t border-amber-400 pt-2'>
						<span class='animate-pulse'>●</span> HTTPS protects browser-to-website connection
						<span class='animate-pulse'>●</span> n8n automation service can read message content
						<span class='animate-pulse'>●</span> Not end to end encrypted (intermediaries can access)
					</div>
				</div>
			</div>
			
			<!-- Import Security Info Component -->
			<div class="mt-6">
				<SecurityInfo />
			</div>
		</div>
	</section>

	<!-- Research Areas -->
	<section class='py-12 border-b'>
		<Grid gridTitle='Research Areas' gridItems={research_areas} />
	</section>

	<!-- Recent Publications -->
	<section class='py-12 border-t'>
		<ArticleList listTitle='Recent Publications' listItems={publications} />
	</section>
	</div>
</Layout>

<script is:inline>
// Home Terminal functionality - Enhanced with typing effects
let homeCurrentMessage = '';
let homeInitializationInProgress = false;  // Track if initialization is in progress
let homeTypingIntervals = []; // Store all typing intervals for proper cleanup

// Add message to home terminal output with typing effect
function addToHomeTerminal(text, className = '', withTyping = false, delay = 30) {
    const output = document.getElementById('home-terminal-output');
    if (!output) return;
    
    const line = document.createElement('div');
    if (className) line.className = className;
    
    if (withTyping && text.trim()) {
        // Typing effect
        let i = 0;
        line.textContent = '';
        output.appendChild(line);
        
        const typeInterval = setInterval(() => {
            if (i < text.length) {
                line.textContent += text.charAt(i);
                i++;
                output.scrollTop = output.scrollHeight;
            } else {
                // Clean up this interval once done
                clearInterval(typeInterval);
                const index = homeTypingIntervals.indexOf(typeInterval);
                if (index > -1) {
                    homeTypingIntervals.splice(index, 1);
                }
            }
        }, delay);
        
        // Store interval reference for cleanup
        homeTypingIntervals.push(typeInterval);
    } else {
        // Instant display for empty lines or when typing disabled
        line.textContent = text;
        output.appendChild(line);
    }
    
    output.scrollTop = output.scrollHeight;
}

// Handle Enter key press for home terminal
function handleHomeTerminalInput(event) {
    if (event.key === 'Enter') {
        event.preventDefault();
        const input = document.getElementById('home-terminal-input');
        const message = input ? input.value.trim() : '';
        
        if (message) {
            addToHomeTerminal('> ' + message, 'text-green-400');
            homeCurrentMessage = message;
            if (input) input.value = '';
            sendHomeTerminalMessage();
        }
    }
}

// Send message function for home terminal
async function sendHomeTerminalMessage() {
    const input = document.getElementById('home-terminal-input');
    let message = homeCurrentMessage || (input ? input.value.trim() : '');
    
    if (!message) {
        addToHomeTerminal('Error: Empty message', 'text-red-400');
        return;
    }

    // SECURITY: Rate limiting check
    const now = Date.now();
    const lastSent = localStorage.getItem('lastHomeMessageSent');
    const minInterval = 5000; // 5 seconds between messages
    
    if (lastSent && (now - parseInt(lastSent)) < minInterval) {
        const remaining = Math.ceil((minInterval - (now - parseInt(lastSent))) / 1000);
        addToHomeTerminal(`Rate limit: Wait ${remaining} seconds before sending another message`, 'text-red-400');
        return;
    }

    // SECURITY: Message length validation
    if (message.length > 1000) {
        addToHomeTerminal('Error: Message too long (max 1000 characters)', 'text-red-400');
        return;
    }

    // SECURITY: Enhanced content filtering with multiple encoding detection
    let decodedMessage = message;
    let doubleDecodedMessage = message;
    
    try {
        // First level URL decoding
        decodedMessage = decodeURIComponent(message);
        // Double decoding to catch double-encoded attacks
        doubleDecodedMessage = decodeURIComponent(decodedMessage);
    } catch (e) {
        // If decoding fails, use original message
    }
    
    // Also check for HTML entity decoding
    let htmlDecodedMessage = message
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#x27;/g, "'")
        .replace(/&#39;/g, "'")
        .replace(/&amp;/g, '&');
    
    const suspiciousPatterns = [
        /script[^>]*>/i,
        /javascript:/i,
        /data:text\/html/i,
        /<iframe/i,
        /eval\(/i,
        /document\.cookie/i,
        /on\w+\s*=/i,  // Event handlers like onclick, onerror, etc.
        /expression\s*\(/i,  // CSS expression attacks
        /vbscript:/i,  // VBScript protocol
        /livescript:/i,  // LiveScript protocol
        /mocha:/i,  // Mocha protocol
        /&#/i,  // HTML entity encoding attempts
        /%3c/i,  // URL encoded < character
        /%3e/i,  // URL encoded > character
        /%22/i,  // URL encoded " character
        /%27/i   // URL encoded ' character
    ];
    
    // Check original, decoded, double-decoded, and HTML decoded messages
    const messagesToCheck = [message, decodedMessage, doubleDecodedMessage, htmlDecodedMessage];
    for (const msgToCheck of messagesToCheck) {
        if (suspiciousPatterns.some(pattern => pattern.test(msgToCheck))) {
            addToHomeTerminal('Error: Message contains potentially harmful content', 'text-red-400');
            addToHomeTerminal('Security: Encoded/obfuscated attacks detected and blocked', 'text-yellow-400');
            return;
        }
    }

    // If called directly (button click), show the message first
    if (!homeCurrentMessage && message) {
        addToHomeTerminal('> ' + message, 'text-green-400');
    }
    
    try {
        addToHomeTerminal('Establishing secure connection...', 'text-blue-400', true, 25);
        
        // SECURITY: Add request timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
        
        const response = await fetch('https://crypt0grapher.app.n8n.cloud/webhook/3145da13-aca7-4299-8046-07bcae2173a7', {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                // SECURITY: Add basic fingerprinting protection
                'X-Client-Version': '1.0.0'
            },
            body: JSON.stringify({
                message: message.substring(0, 1000), // Truncate message
                timestamp: new Date().toISOString(),
                source: 'home_terminal',
                // SECURITY: Add client fingerprint for rate limiting on server side
                fingerprint: btoa(navigator.userAgent.substring(0, 50) + window.location.origin).substring(0, 32)
            }),
            signal: controller.signal
        });

        clearTimeout(timeoutId);
        
        // SECURITY: Update rate limiting timestamp
        localStorage.setItem('lastHomeMessageSent', now.toString());

        if (response.ok) {
            addToHomeTerminal('✓ Message delivered to automation server', 'text-green-400', true, 30);
            addToHomeTerminal('✓ Forwarding directly to Hosein\'s Telegram...', 'text-cyan-400', true, 25);
        } else {
            addToHomeTerminal('✓ Message processed by webhook', 'text-green-400', true, 30);
        }
        
        addToHomeTerminal('', '');
        
    } catch (error) {
        if (error.name === 'AbortError') {
            addToHomeTerminal('Request timeout - please try again', 'text-red-400');
        } else {
            addToHomeTerminal('Network timeout - message likely delivered', 'text-yellow-400', true, 35);
        }
        addToHomeTerminal('', '');
    }
    
    // Clean up
    homeCurrentMessage = '';
    if (input) input.value = '';
}

// Clear home terminal with proper cleanup
function clearHomeTerminal() {
    // Stop all active typing intervals first
    if (homeTypingIntervals && homeTypingIntervals.length) {
        homeTypingIntervals.forEach(interval => clearInterval(interval));
        homeTypingIntervals = [];
    }

    // Clear content
    const output = document.getElementById('home-terminal-output');
    const input = document.getElementById('home-terminal-input');
    if (output) output.innerHTML = '';
    if (input) input.value = '';
    
    // Show confirmation message with typing effect
    addToHomeTerminal('Terminal cleared - ready for new message', 'text-green-400', true, 40);
    addToHomeTerminal('', '');
}

// Reset and properly clean up home terminal
function resetHomeTerminal() {
    // Stop all active typing intervals
    if (homeTypingIntervals && homeTypingIntervals.length) {
        homeTypingIntervals.forEach(interval => clearInterval(interval));
        homeTypingIntervals = [];
    }
    
    // Clear terminal content
    const output = document.getElementById('home-terminal-output');
    if (output) {
        output.innerHTML = '';
    }
    
    // Reset initialization flag
    homeInitializationInProgress = false;
}

// Initialize home terminal content with enhanced typing
function initializeHomeTerminal() {
    // Prevent multiple simultaneous initializations
    if (homeInitializationInProgress) return;
    homeInitializationInProgress = true;
    
    const output = document.getElementById('home-terminal-output');
    if (!output) {
        homeInitializationInProgress = false;
        return; // Exit if terminal not found
    }
    
    // Full reset before initializing
    resetHomeTerminal();
    
    // Queue of messages to type out - Home page specific
    const messages = [
        { text: 'Quick Message Terminal - Security Analysis', class: 'text-green-400', typing: true, delay: 45 },
        { text: '======================================', class: 'text-green-400', typing: true, delay: 15 },
        { text: '', class: '', typing: false },
        { text: 'Security breakdown of this messaging system:', class: 'text-cyan-400', typing: true, delay: 40 },
        { text: '1. HTTPS protects messages in transit from browser to website', class: 'text-gray-400', typing: true, delay: 25 },
        { text: '2. Messages sent to n8n over HTTPS but accessible within the n8n service', class: 'text-yellow-400', typing: true, delay: 25 },
        { text: '3. Messages are then forwarded directly to my Telegram via Telegram\'s API', class: 'text-green-400', typing: true, delay: 25 },
        { text: '4. No persistent storage beyond rate limiting timestamps', class: 'text-gray-400', typing: true, delay: 25 },
        { text: '', class: '', typing: false },
        { text: 'This demonstrates the need for end-to-end encryption', class: 'text-amber-400', typing: true, delay: 30 },
        { text: 'Type your message and press Enter... trust issues? a cryptographer would understand ;)', class: 'text-yellow-400', typing: true, delay: 50 },
        { text: '', class: '', typing: false }
    ];
    
    let currentIndex = 0;
    let allTimeouts = []; // Track all timeouts for cleanup
    
    function typeNextMessage() {
        if (!document.getElementById('home-terminal-output')) {
            // Terminal no longer exists (navigated away), clean up
            allTimeouts.forEach(timeout => clearTimeout(timeout));
            homeInitializationInProgress = false;
            return;
        }
        
        if (currentIndex < messages.length) {
            const msg = messages[currentIndex];
            addToHomeTerminal(msg.text, msg.class, msg.typing, msg.delay);
            currentIndex++;
            
            // Wait for typing to complete before next message
            const waitTime = msg.typing ? (msg.text.length * msg.delay) + 150 : 80;
            const timeout = setTimeout(typeNextMessage, waitTime);
            allTimeouts.push(timeout);
        } else {
            // All messages typed, focus on input
            const input = document.getElementById('home-terminal-input');
            if (input) input.focus();
            homeInitializationInProgress = false;
        }
    }
    
    // Start typing sequence
    typeNextMessage();
}

// Initialize home terminal - strict single initialization approach
function setupHomeTerminalInitialization() {
    // Store when the terminal was last initialized to strictly control timing
    let lastHomeTerminalInit = 0;
    const initDebounceTime = 1500; // Longer time to prevent multiple initializations
    let initializationTimeout = null;
    
    // Clean, strict debounced initialization
    function strictDebouncedInit() {
        // Clear any pending initialization
        if (initializationTimeout) {
            clearTimeout(initializationTimeout);
            initializationTimeout = null;
        }
        
        const now = Date.now();
        if (now - lastHomeTerminalInit > initDebounceTime) {
            // Reset completely before setting new timeout
            resetHomeTerminal();
            
            // Set a timeout for initialization
            initializationTimeout = setTimeout(() => {
                lastHomeTerminalInit = Date.now();
                initializeHomeTerminal();
                initializationTimeout = null;
            }, 300); // Slight delay to ensure cleanup is complete
        }
    }
    
    // Initial load handling - single point of initialization
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            if (document.getElementById('home-terminal-output')) {
                strictDebouncedInit();
            }
        });
    } else {
        if (document.getElementById('home-terminal-output')) {
            strictDebouncedInit();
        }
    }
    
    // Page visibility (tab switching) handling
    document.addEventListener('visibilitychange', () => {
        if (!document.hidden && document.getElementById('home-terminal-output') && 
            !homeInitializationInProgress && document.querySelector('[data-page="home"]')) {
            strictDebouncedInit();
        }
    });
    
    // Astro navigation event - most important for SPA navigation
    document.addEventListener('astro:page-load', () => {
        if (document.getElementById('home-terminal-output') && document.querySelector('[data-page="home"]')) {
            strictDebouncedInit();
        }
    });
    
    // Cleanup on navigation away
    document.addEventListener('astro:before-preparation', () => {
        resetHomeTerminal();
    });
}

// Run setup
setupHomeTerminalInitialization();

// Make functions globally available
window.sendHomeTerminalMessage = sendHomeTerminalMessage;
window.clearHomeTerminal = clearHomeTerminal;
window.handleHomeTerminalInput = handleHomeTerminalInput;
</script>
